#!/bin/env make

$(shell cp -u configs/.env.example configs/.env)
-include configs/.env
export

CGO_ENABLED       =  0
GO111MODULE  	  =  on
GO                =  $(shell which go)
CFG_DIR           =  configs
DOCKER_DIR        =  deploy## docker dir (for docker-compose and Dockerfile)

SCRIPTS_DIR       ?= $(PWD)/scripts## path to the shell scripts-helpers
BIN_DIR	          ?= $(PWD)/bin## path for the build binaries and 3rd party tools
CFG_FILE          ?= $(PWD)/${CFG_DIR}/.env## path for configuration files
BUILD_DATE        =  $(shell date +"%F %T %Z")
GIT_COMMIT        =  $(shell git rev-parse HEAD)
GIT_TAG           ?= $(shell git describe --tags --abbrev=0 2>/dev/null)
M                 =  $(shell printf "\033[34;1m>>\033[0m")

# Detect OS for cross-compilation in the future.
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
	OSFLAG := linux
else
	OSFLAG := osx
endif

export BUILD_DATE
export GIT_COMMIT
export GIT_TAG
export GO111MODULE
export CGO_ENABLED
export CFG_FILE
export GOOS     := $(OSFLAG)
export GOBIN    := $(BIN_DIR)
export PATH     := $(GOBIN):$(PATH)

.PHONY: init
init: install-tools fmt
	$(info $(M) go mod tidy)
	@($(GO) mod tidy -v)

	$(info $(M) building docker-compose images if needed)
	docker-compose build --progress tty --no-cache

	$(shell wait)
	$(info $(M) FINISHED!)


build: ## Build all of services binaries
	$(info $(M) building binaries into $(BIN_DIR) directory)
	@(BUILD_TAGS="$${BTAGS}" TARGETS_PATH="$(PWD)/cmd" ./scripts/build-binary.sh)


build-docker-app: ## Build Docker image any target, e.g.: make build-docker-app target={server,guide,client}
	@docker build \
		--build-arg "TARGET=$(target)" \
		--build-arg "BUILD_DATE=$(BUILD_DATE)" \
		--build-arg "GIT_COMMIT=$(GIT_COMMIT)" \
		--build-arg "GOOS=$(GOOS)" \
		--build-arg "CGO_ENABLED=$(CGO_ENABLED)" \
		-t $(target):$(GIT_TAG) \
		-t $(target):latest .

build-docker: ## Build Docker images for all of services
	$(info $(M) building server Docker image)
	@(MAKE) build-docker-app target=server

	$(info $(M) building client Docker image)
	@(MAKE) build-docker-app target=client

	$(info $(M) building guide Docker image)
	@(MAKE) build-docker-app target=guide


.PHONY: install-tools
install-tools: ## Install tools required to work with the project
	$(info $(M) checking for tools needed)
	@(mkdir -p "$(BIN_DIR)")
	@(echo "GOBIN=$(GOBIN) BIN_DIR=$(BIN_DIR) ./scripts/install-helper-tools.sh")
	@(GOBIN=$(GOBIN) BIN_DIR=$(BIN_DIR) ./scripts/install-helper-tools.sh)


.PHONY: lint
lint: fmt ## Run go linting processes
	$(info $(M) running with config ./${CFG_DIR}/.golangci.yml)
	$(BIN_DIR)/golangci-lint run --config ./${CFG_DIR}/.golangci.yml ./...


.PHONY: fmt
fmt: install-tools ## Do code formatting
	$(info $(M) running with goimports and gofumpt tools...)
	$(BIN_DIR)/goimports -l -w .
	$(BIN_DIR)/gofumpt -l -w .


.PHONY: docker-restart
docker-restart: docker-stop docker-up ## Alias for docker-stop and docker-start.

.PHONY: docker-up
docker-up: ## Starts local dev environment
	$(info $(M) starting local dev environment...)
	@(docker-compose \
		--env-file=${CFG_DIR}/.env \
		--project-directory=$(PWD) \
		--file=$(CFG_DIR)/docker-compose.yml up)


.PHONY: docker-stop
docker-stop: ## Stops local dev environment
	$(info $(M) stopping local dev environment...)
	@(docker-compose \
		--env-file=${CFG_DIR}/.env \
		--project-directory=$(PWD) \
		--file=$(CFG_DIR)/docker-compose.yml stop)


.PHONY: docker-clean ## Cleaning docker images, footprint
docker-clean: docker-stop
	$(info $(M) cleaning local docker environment...)
	@(docker-compose \
		--env-file=${CFG_DIR}/.env \
		--project-directory=$(PWD) \
		--file=$(CFG_DIR)/docker-compose.yml -v --remove-orphans --rmi local)

.PHONY: clean
BIN_BASE=$(shell basename $(BIN_DIR))
clean: docker-clean ## Clean up the DB footprint, artefacts etc.
	$(info $(M) cleaning up generated by init files. You should do to reinit project 'make init')
	@(rm -rf ./$(BIN_BASE) ./$(CFG_DIR)/.env)


.PHONY: help
help: ## Show this help
	@grep -E '^[a-z][^:]+:.*?## .*$$' $(MAKEFILE_LIST) | sed "s/Makefile://g" | sed "s/:.*## /::/g" | \
		awk 'BEGIN {FS = "::"}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}' | \
		awk 'BEGIN {FS = ":"}; {printf "%s \033[36m%s\033[0m\n", $$1, $$2}'

%:
	@true
